# 内核启动再探

重新思考内核启动。

## acpi 

之前一直不知道 acpi 究竟是什么东西，这个东西就是一个规范，规定一些信息放在哪个内存地址上，由 uefi 设置。在 linux 系统中，能够通过一些调用和解释器解释其中的信息，实际上探测 NUMA 拓扑，热插拔管理等等都需要使用到 acpi。

## 启动时候内存使用

x86 在实模式和保护模式下不分页的，地址计算有自己的方式，而在长模式下是分页的。linux 有启动协议，规定了内核会加载在哪个位置，在编译的时候用链接脚本规定好了放的地址在哪里。同时初始化一旦开始进入到长地址模式，分页就会开启，因此在进去之前还在保护模式的时候，先会把页表设置好，给它物理地址空间分配出来，然后再进长地址模式。进去之后先初始化中断，先简单的设置中断处理，给自己初始化缺页时候用，这个缺页处理的函数并不是最后用的，这里的管理会简单点。等到正式中断初始化完成之后，才把处理函数正式设置缺页的。

bootloader 只是把内核镜像拷贝到指定物理内存位置，将启动参数放到指定的位置，然后跳转到指定地址就进入内核了。内核自己会把内核解压到一定的物理地址上，然后构建页表（vaddr->paddr，是链接脚本规定的，编译内核的时候链接脚本规定了生成的 elf 虚拟地址，在解压之后，启动代码能读出之前把虚拟地址并建立到自己选定的物理内存地址的映射）映射到内核，然后跳到内核入口，这时候内核入口就走页表过了。